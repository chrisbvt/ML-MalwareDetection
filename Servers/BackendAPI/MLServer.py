import datetime
import argparse
import ConfigParser
import joblib
import json
import pickle
import io
import numpy as np
import pandas as pd

from sklearn.feature_extraction.text import CountVectorizer
from flask import Flask, jsonify, request, g, url_for, abort
from OpenSSL import SSL

SECONDS_IN_HOUR = 4320
ml_Server = Flask(__name__)
redis_db = None

encoder_imports = None
encoder_strings = None
imports_clf = None
final_clf = None

@ml_Server.route('/ml')
def index():
    return "Blue Sentry Learner"


@ml_Server.route('/ml/classify_file', methods=['POST'])
def is_malicious():

    sha1 = request.form['sha1']
    md5 = request.form['md5']
    metadata = request.form['metadata']

    print sha1
    print md5

    if sha1 is None or md5 is None or metadata is None:
        abort(400)
    ##########################
    # TODO: Whitelist Server #
    ##########################

    ##########################
    # TODO: Buffer Server    #
    ##########################

    csv_non_formatted = pickle.loads(metadata)
    csv_file = io.BytesIO(csv_non_formatted)
    data = pd.read_csv(csv_file)
    df_imports = data['imports']
    df_strings = data['strings']
    data_imports_encoded = encoder_imports.transform(df_imports)
    data_strings_encoded = encoder_strings.transform(df_strings)

    pred_prob_strings = strings_clf.predict_proba(data_strings_encoded)

    pred_prob_rounded_strings = []
    for x in range(0, data_strings_encoded.shape[0]):
        pred_prob_rounded_strings.append(round(pred_prob_strings[x][1], 8))
    data['strings_processed'] = pred_prob_rounded_strings

    pred_prob_imports = imports_clf.predict_proba(data_imports_encoded)
    pred_prob_rounded_imports = []
    for x in range(0, data_imports_encoded.shape[0]):
        pred_prob_rounded_imports.append(round(pred_prob_imports[x][1], 8))
    data['imports_processed'] = pred_prob_rounded_imports

    data = data[['sha256', 'size', 'signed', 'good_file', 'entropy', 'imports_processed', 'strings_processed']]

    data_names = data['sha256']
    data = data.drop(['sha256'], axis=1)
    data = data.drop(['size'], axis=1)
    data = data.drop(['good_file'], axis=1)

    predictions = final_clf.predict(data)

    pred_prob_final = final_clf.predict_proba(data)
    pred_prob_rounded_final = []
    for x in range(0, 1):
        pred_prob_rounded_final.append(round(pred_prob_final[x][1], 8))

    prediction_imports_score = pred_prob_rounded_imports[0]
    print "Imports Predictions:"
    print prediction_imports_score
    prediction_strings_score = pred_prob_rounded_strings[0]
    print "Strings Predictions:"
    print prediction_strings_score
    prediction_final_score = pred_prob_rounded_final[0]
    print "Final Prediction Score:"
    print prediction_final_score
    malicious = abs(1 - predictions[0])

    predictions_dictionary = {'final_prediction_score': prediction_final_score, 'string_prediction_score':
                    prediction_strings_score, 'imports_prediction_score': prediction_imports_score,
                   'Malicious': malicious}

    return jsonify(predictions_dictionary)

def update_memory_bank():
    pass


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--config_file', help="Configuration File Machine Learning Servers")
    args = parser.parse_args()

    config = ConfigParser.ConfigParser()
    config.read(args.config_file)

    options = config.options('Learner')

    opts_dict = {}
    for option in options:
        opts_dict[option] = config.get('Learner', option)

    print opts_dict
    ip = opts_dict['server_ip']
    port = int(opts_dict['port'])
    mb_host = opts_dict['mb_host']
    mb_port = opts_dict['mb_port']
    imports_encoder_path = opts_dict['imports_encoder']
    strings_encoder_path = opts_dict['strings_encoder']
    imports_classifier_path = opts_dict['imports_classifier']
    strings_classifier_path = opts_dict['strings_classifier']
    stage2_classifier_path = opts_dict['stage2_classifier']

    context = SSL.Context(SSL.SSLv23_METHOD)
    context = ('server.crt', 'server.key')

    encoder_imports = joblib.load(imports_encoder_path)
    print "Loaded imports encoder!"
    encoder_strings = joblib.load(strings_encoder_path)
    print "Loaded strings encoder!"
    imports_clf = joblib.load(imports_classifier_path)
    print "Loaded imports classifier!"
    strings_clf = joblib.load(strings_classifier_path)
    print "Loaded strings classifier!"
    final_clf = joblib.load(stage2_classifier_path)
    print "Loaded stage2 classifier!"

    ml_Server.run(debug=True, port=port, host=ip, ssl_context=context)
